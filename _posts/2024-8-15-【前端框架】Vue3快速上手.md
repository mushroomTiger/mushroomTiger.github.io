# Vue3 核心知识点详解

## 一、Vue3 简介

- **发布时间**：2020年9月18日
- **代号**：One Piece（海贼王）
- **开发历程**：
  - 耗时2年多
  - 2600+次提交
  - 30+个RFC
  - 600+次PR
  - 99位贡献者
- **GitHub发布地址**：https://github.com/vuejs/vue-next/releases/tag/v3.0.0

## 二、Vue3 带来的变化

### 1. 性能提升
- 打包大小减少41%
- 初次渲染快55%
- 更新渲染快133%
- 内存减少54%

### 2. 源码升级
- 使用Proxy代替defineProperty实现响应式
- 重写虚拟DOM的实现
- 支持Tree-Shaking

### 3. 更好的TypeScript支持
- Vue3可以更好地支持TypeScript

### 4. 新特性
#### Composition API（组合API）
- setup配置
- ref与reactive
- watch与watchEffect
- provide与inject

#### 新的内置组件
- Fragment
- Teleport
- Suspense

#### 其他改变
- 新的生命周期钩子
- data选项应始终被声明为一个函数
- 移除keyCode支持作为v-on的修饰符

## 三、创建Vue3工程

### 方式一：使用vue-cli创建
```bash
# 查看@vue/cli版本，确保在4.5.0以上
vue --version

# 安装或升级@vue/cli
npm install -g @vue/cli

# 创建项目
vue create vue_test

# 启动项目
cd vue_test
npm run serve
```

### 方式二：使用vite创建
**vite介绍**：新一代前端构建工具
- 优势：
  - 快速冷启动
  - 轻量快速的热重载（HMR）
  - 真正的按需编译

```bash
# 创建工程
npm init vite-app <project-name>

# 进入工程目录
cd <project-name>

# 安装依赖
npm install

# 运行
npm run dev
```

## 四、Composition API详解

### 1. setup函数
- Vue3.0中新的配置项，值为函数
- Composition API的"舞台"
- 组件中的数据、方法等都配置在setup中

**返回值**：
1. 返回对象：对象中的属性、方法在模板中可直接使用
2. 返回渲染函数：可自定义渲染内容

**注意点**：
- 尽量避免与Vue2.x配置混用
- setup不能是async函数（除非配合Suspense）

### 2. 响应式API

#### ref函数
- 定义响应式数据（基本类型或对象类型）
- 创建引用对象（reference对象）
- JS中操作：`xxx.value`
- 模板中读取：直接使用`{{xxx}}`

```javascript
import { ref } from 'vue'

const count = ref(0)
count.value++ // JS中操作
```

#### reactive函数
- 定义对象类型的响应式数据
- 返回Proxy代理对象
- 深层次的响应式

```javascript
import { reactive } from 'vue'

const state = reactive({
  count: 0,
  user: {
    name: 'John'
  }
})
```

### 3. Vue3响应式原理
#### Vue2.x响应式问题
- 对象：Object.defineProperty
- 数组：重写数组方法
- 问题：
  - 新增/删除属性界面不更新
  - 直接通过下标修改数组不更新

#### Vue3.0响应式实现
- 通过Proxy拦截对象变化
- 通过Reflect操作源对象

```javascript
new Proxy(data, {
  get(target, prop) {
    return Reflect.get(target, prop)
  },
  set(target, prop, value) {
    return Reflect.set(target, prop, value)
  },
  deleteProperty(target, prop) {
    return Reflect.deleteProperty(target, prop)
  }
})
```

### 4. ref与reactive对比
| 角度 | ref | reactive |
|------|-----|----------|
| 定义数据 | 基本类型数据 | 对象/数组类型数据 |
| 原理 | Object.defineProperty | Proxy |
| 使用 | 需要`.value` | 不需要`.value` |

### 5. 计算与监视

#### computed函数
```javascript
import { computed } from 'vue'

// 简写
const fullName = computed(() => firstName + '-' + lastName)

// 完整
const fullName = computed({
  get() {
    return firstName + '-' + lastName
  },
  set(value) {
    const nameArr = value.split('-')
    firstName = nameArr[0]
    lastName = nameArr[1]
  }
})
```

#### watch函数
```javascript
import { watch } from 'vue'

// 监视ref定义的数据
watch(count, (newVal, oldVal) => {
  console.log('count变化了', newVal, oldVal)
})

// 监视多个数据
watch([count, msg], (newVals, oldVals) => {
  console.log('count或msg变化了', newVals, oldVals)
})

// 监视reactive定义的对象的某个属性
watch(() => state.count, (newVal, oldVal) => {
  console.log('count变化了', newVal, oldVal)
})
```

#### watchEffect函数
- 自动追踪依赖
- 无需指定监视属性

```javascript
watchEffect(() => {
  console.log('依赖变化:', count.value, state.name)
})
```

### 6. 生命周期

Vue2.x
![](../assets/img/images/vue2LifeCycle.png)
Vue3.x
![](../assets/img/images/vue3LifeCycle.png)
Vue2.x与Vue3.0生命周期对应关系：

| Vue2.x | Vue3.0 (Options API) | Vue3.0 (Composition API) |
|--------|----------------------|---------------------------|
| beforeCreate | beforeCreate | setup() |
| created | created | setup() |
| beforeMount | beforeMount | onBeforeMount |
| mounted | mounted | onMounted |
| beforeUpdate | beforeUpdate | onBeforeUpdate |
| updated | updated | onUpdated |
| beforeDestroy | beforeUnmount | onBeforeUnmount |
| destroyed | unmounted | onUnmounted |

### 7. 自定义hook函数
- 本质：封装Composition API的函数
- 优势：代码复用，逻辑清晰

```javascript
// useMouse.js
import { ref, onMounted, onUnmounted } from 'vue'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)
  
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }
  
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))
  
  return { x, y }
}
```

### 8. toRef与toRefs
- 将响应式对象的属性转为ref对象
- 保持响应式连接

```javascript
import { toRef, toRefs } from 'vue'

const state = reactive({ name: 'John', age: 30 })

// 单个属性
const nameRef = toRef(state, 'name')

// 所有属性
const stateRefs = toRefs(state)
```

## 五、其他Composition API

### 1. 浅层响应式
- `shallowReactive`：只处理对象最外层属性的响应式
- `shallowRef`：不处理对象的响应式

### 2. 只读代理
- `readonly`：深只读
- `shallowReadonly`：浅只读

### 3. 原始对象操作
- `toRaw`：reactive对象转普通对象
- `markRaw`：标记对象永不成为响应式

### 4. 自定义ref
```javascript
function useDebouncedRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger()
        }, delay)
      }
    }
  })
}
```

### 5. 依赖注入
```javascript
// 祖先组件
provide('key', value)

// 后代组件
const value = inject('key')
```

### 6. 响应式判断
- `isRef`：检查是否为ref对象
- `isReactive`：检查是否为reactive代理
- `isReadonly`：检查是否为只读代理
- `isProxy`：检查是否为reactive或readonly代理

## 六、Composition API优势

### Options API的问题
- 功能代码分散在data、methods、computed等选项中
- 修改功能需要在多个位置修改
![](../assets/img/images/optionsApiProblem1.image)
![](../assets/img/images/optionsApiProblem2.image)

### Composition API优势
- 相关功能代码组织在一起
- 更好的代码复用
- 更好的TypeScript支持
![](../assets/img/images/optionsApiAdvantage1.image)
![](../assets/img/images/optionsApiAdvantage2.image)

## 七、新组件

### 1. Fragment
- Vue3组件可以没有根标签
- 减少标签层级和内存占用

### 2. Teleport
- 将组件HTML结构移动到指定位置

```vue
<teleport to="body">
  <div class="modal">
    <!-- 弹窗内容 -->
  </div>
</teleport>
```

### 3. Suspense
- 异步组件加载时的占位显示

```vue
<Suspense>
  <template #default>
    <AsyncComponent />
  </template>
  <template #fallback>
    <div>加载中...</div>
  </template>
</Suspense>
```

## 八、其他变化

### 1. 全局API转移
| Vue2.x全局API | Vue3.x实例API |
|---------------|---------------|
| Vue.config.xxxx | app.config.xxxx |
| Vue.component | app.component |
| Vue.directive | app.directive |
| Vue.mixin | app.mixin |
| Vue.use | app.use |
| Vue.prototype | app.config.globalProperties |

### 2. 其他重要变化
1. **data选项**：必须声明为函数
2. **过渡类名变更**：
   ```css
   /* Vue3 */
   .v-enter-from,
   .v-leave-to { opacity: 0; }
   
   .v-leave-from,
   .v-enter-to { opacity: 1; }
   ```
3. **移除keyCode修饰符**
4. **移除v-on.native修饰符**
5. **移除过滤器（filter）**
6. **移除$on、$off、$once实例方法**